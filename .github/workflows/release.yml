name: Release

on:
  push:
    branches:
      - main  # Only run on main branch pushes (PR merges)
  pull_request:
    types: [ opened, synchronize, reopened, labeled, unlabeled ]

permissions: {}

jobs:
  release-pr:
    permissions:
      contents: write
      pull-requests: write
      issues: write
      statuses: write
    runs-on: ubuntu-latest
    outputs:
      release_pr: ${{ toJSON(steps.release-pr.outputs) }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit

      - name: Checkout
        uses: actions/checkout@v5
      - uses: actionutils/trusted-tag-verifier@68bef2f18f8ceb5c4dccc5542cadcfbc82ed4656 # v0.5.0
        with:
          verify: 'actionutils/create-release-pr'
      - uses: actionutils/create-release-pr@v0
        id: release-pr

  update-release-pr:
    needs: [release-pr]
    if: fromJSON(needs.release-pr.outputs.release_pr).state == 'release_pr_open'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      id-token: write # Required for OIDC token exchange
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit
      - uses: actions/checkout@v5
        with:
          ref: ${{ fromJSON(needs.release-pr.outputs.release_pr).pr_branch }}
          fetch-depth: 2  # Need at least 2 commits to check and potentially reset
      - uses: actions/dependency-review-action@v4
        id: dependency-review
        with:
          base-ref: ${{ fromJSON(needs.release-pr.outputs.release_pr).current_tag }}
          head-ref: main

      - name: Update README installation section
        if: fromJSON(needs.release-pr.outputs.release_pr).next_tag != ''
        env:
          VERSION: ${{ fromJSON(needs.release-pr.outputs.release_pr).next_tag }}
        run: |
          # Build kugiri first
          cargo build --release
          # Update README with new version
          ./scripts/update-installation.sh "$VERSION"

      - uses: ./.github/actions/smart-commit
        with:
          commit_message: "docs: Update README installation section to ${{ fromJSON(needs.release-pr.outputs.release_pr).next_tag }}"
          trailer_id: readme-update
          branch: ${{ fromJSON(needs.release-pr.outputs.release_pr).pr_branch }}
          files: |
            README.md


      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install cargo-edit
        if: fromJSON(needs.release-pr.outputs.release_pr).next_tag != ''
        uses: taiki-e/cache-cargo-install-action@b33c63d3b3c85540f4eba8a4f71a5cc0ce030855 # v2.3.0
        with:
          tool: cargo-edit
      - name: Bump version in Cargo.{toml,lock}
        if: fromJSON(needs.release-pr.outputs.release_pr).next_tag != ''
        env:
          VERSION: ${{ fromJSON(needs.release-pr.outputs.release_pr).next_tag }}
        run: |
          # Remove 'v' prefix if present for cargo set-version
          VERSION=${VERSION#v}
          cargo set-version "$VERSION"

      - uses: ./.github/actions/smart-commit
        if: fromJSON(needs.release-pr.outputs.release_pr).next_tag != ''
        with:
          commit_message: "chore: Bump version to ${{ fromJSON(needs.release-pr.outputs.release_pr).next_tag }}"
          trailer_id: cargo-version-bump
          branch: ${{ fromJSON(needs.release-pr.outputs.release_pr).pr_branch }}
          files: |
            Cargo.toml
            Cargo.lock

      # Update CHANGELOG last as it's most likely to change
      - name: Update CHANGELOG with release notes
        if: fromJSON(needs.release-pr.outputs.release_pr).next_tag != ''
        env:
          VERSION: ${{ fromJSON(needs.release-pr.outputs.release_pr).next_tag }}
          RELEASE_NOTES: ${{ fromJSON(needs.release-pr.outputs.release_pr).release_notes }}
        run: |
          # Create auto-generated title
          TITLE="# [$VERSION](https://github.com/${{ github.repository }}/releases/tag/$VERSION) - $(date +%Y-%m-%d)"

          # Check if {version} section exists
          if ./target/release/kugiri extract CHANGELOG.md --id "$VERSION" > /tmp/existing_section.md 2>/dev/null; then
            echo "Found existing $VERSION section, updating auto-generated parts directly in CHANGELOG"

            # Update the auto-generated-title directly in CHANGELOG
            echo "$TITLE" | ./target/release/kugiri update CHANGELOG.md \
              --id "${VERSION}-auto-generated-title" \
              --write

            # Update the auto-generated-notes directly in CHANGELOG
            echo "$RELEASE_NOTES" | ./target/release/kugiri update CHANGELOG.md \
              --id "${VERSION}-auto-generated-notes" \
              --write
          else
            echo "No existing $VERSION section found, creating new structure"

            # Create new section with wrapped auto-generated parts
            echo "$TITLE" | ./target/release/kugiri wrap --id "${VERSION}-auto-generated-title" > /tmp/complete_entry.md
            echo "" >> /tmp/complete_entry.md
            # Create notes with auto-generated-notes inside
            echo "$RELEASE_NOTES" | ./target/release/kugiri wrap --id "${VERSION}-auto-generated-notes" | \
              ./target/release/kugiri wrap --id "${VERSION}-notes" >> /tmp/complete_entry.md

            # Insert new section after changelog marker
            ./target/release/kugiri insert CHANGELOG.md \
              --id "$VERSION" \
              --body-file /tmp/complete_entry.md \
              --after "changelog" \
              --write
          fi

      - uses: ./.github/actions/smart-commit
        with:
          commit_message: "docs: Update CHANGELOG for ${{ fromJSON(needs.release-pr.outputs.release_pr).next_tag }}"
          trailer_id: changelog-update
          branch: ${{ fromJSON(needs.release-pr.outputs.release_pr).pr_branch }}
          files: |
            CHANGELOG.md


      - uses: mlugg/setup-zig@8d6198c65fb0feaa111df26e6b467fea8345e46f # v2.0.5
      - uses: sigstore/cosign-installer@v3.9.2 # installs cosign
      - uses: anchore/sbom-action/download-syft@v0.20.5 # installs syft
      # Pre-install cargo-zigbuild before exposing MinGW to avoid Linux linker hijack
      - name: Preinstall cargo-zigbuild
        uses: taiki-e/cache-cargo-install-action@b33c63d3b3c85540f4eba8a4f71a5cc0ce030855 # v2.3.0
        with:
          tool: cargo-zigbuild
          locked: true
      # Provide dlltool for windows-gnu without hijacking cc/c++
      - name: Install mingw binutils (dlltool)
        uses: awalsh128/cache-apt-pkgs-action@2c09a5e66da6c8016428a2172bd76e5e4f14bb17 # v1.5.3
        with:
          packages: binutils-mingw-w64
          version: 1.0
      - uses: goreleaser/goreleaser-action@v6
        id: goreleaser
        with:
          version: '~> v2'
          args: release --clean --draft --snapshot --skip publish
      - uses: actions/upload-artifact@v4
        with:
          name: snapshot
          path: ./dist

  verify-releaser:
    needs: [release-pr]
    if: fromJSON(needs.release-pr.outputs.release_pr).state == 'release_required'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: audit
      - name: Verify Trusted Tag Releaser
        uses: actionutils/trusted-tag-verifier@68bef2f18f8ceb5c4dccc5542cadcfbc82ed4656 # v0.5.0
        with:
          verify: 'actionutils/trusted-go-releaser@v1'

  extract-release-notes:
    needs: [release-pr]
    if: fromJSON(needs.release-pr.outputs.release_pr).state == 'release_required'
    runs-on: ubuntu-latest
    outputs:
      release_notes: ${{ steps.extract.outputs.release_notes }}
    steps:
    - uses: actions/checkout@v5
    - name: Install kugiri
      uses: binary-install/setup-x@v1
      with:
        script_url: https://github.com/actionutils/kugiri/releases/latest/download/install.sh
        gh_attestations_verify_flags: --repo=actionutils/kugiri --signer-workflow=actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml
    - name: Extract release note
      id: extract
      env:
        NEXT_TAG: ${{ fromJSON(needs.release-pr.outputs.release_pr).next_tag }}
      run: |
        NOTE=$(kugiri extract --id "${NEXT_TAG}-notes" CHANGELOG.md | kugiri trim)
        {
          echo "release_notes<<EOF"
          echo "$NOTE"
          echo EOF
        } >> "$GITHUB_OUTPUT"

  release:
    needs: [verify-releaser, release-pr, extract-release-notes]
    if: fromJSON(needs.release-pr.outputs.release_pr).state == 'release_required'
    concurrency:
      group: "release"
      cancel-in-progress: false
    permissions:
      id-token: write    # Required for signed tags
      contents: write    # Required for release and tag creation
      pull-requests: write # Required for bumpr commenting
      attestations: write # Required for build provenance attestation
      actions: read      # Required for SLSA generator
    uses: actionutils/trusted-go-releaser/.github/workflows/trusted-release-workflow.yml@v1
    with:
      environment: release
      setup-zig: true
      install-mingw-dlltool: true
      release-notes: ${{ needs.extract-release-notes.outputs.release_notes }}
    secrets:
      github-token: ${{ secrets.GITHUB_TOKEN }}

  publish:
    needs: [release-pr, release]
    if: fromJSON(needs.release-pr.outputs.release_pr).state == 'release_required'
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC token exchange
    steps:
    - uses: actions/checkout@v5
    - uses: rust-lang/crates-io-auth-action@v1
      id: auth
    - run: cargo publish
      env:
        CARGO_REGISTRY_TOKEN: ${{ steps.auth.outputs.token }}
